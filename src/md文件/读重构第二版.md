# 读重构第二版

## 什么是重构
- 在不改变代码外在行为的前提下，对代码做出修改，已改进程序的内部结构

## 什么情况下要重构
- 当你需要修改一段几百行的代码，发现代码杂乱无章，无法找到修改点
- 除非一段代码永远不会修改，没人需要去理解它，否则就重构

## 重构的步骤
- 第一步，确保即将修改的代码拥有一组可靠的测试
- 第二步，提炼出函数，并立刻编译，测试，然后commit,防止后续搞砸需要回滚（重构技术就是以微小的步伐修改程序）
    - 重新命名函数、函数变量、函数参数
    - 移除不必要的变量（该变量若能通过其他变量计算得来）
    - 长而复杂的函数变量替换为一个明确声明的函数
    - 先完成函数提炼，再考虑性能优化（大多数情况可以忽略）
    - 营地法则：保证离开时的代码库一定比来时更加健康
    - 解决分支逻辑（if else）:以多态取代条件表达式
    - 好代码的检验标准就是是否能够轻而易举地修改它

## 重构的原则
- 重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改
- 重构要保证任何时刻停下来，代码都是可用的
- 两顶帽子：只负责重构和只添加新功能，可以相互变换
- 为何重构
    - 重构改进软件的设计 --使未来可能的修改容易的多
    - 重构使软件更容易理解 --能让其他开发者理解
    - 重构帮助找到bug --清楚的程序结构，想不找到bug都难
    - 重构提高编程速度 --添加新功能会快的多
- 何时重构
    - 事不过三，三则重构
    - 重构的最佳时机在添加新功能之前
    - 见机行事的重构：在添加新功能前、修改bug前为了帮助理解，顺便重构（绝大多数）
    - 有计划的重构：特地花一些时间重构（很少）
    - 长期重构
    - code review时重构
- 何时不用重构
    - 你看见一块丑陋的代码，但你并不需要修改它，就不需要重构
    - 重写比重构容易
- 重构的挑战
    - 延缓新功能开发 --需要权衡取舍，需要明白重构是为了添加功能和修改bug更快
    - 团队开发共享代码，版本控制，持续集成（CI）
    - 自测试代码 --是持续交付的关键环节
    - 遗留代码
- 重构与性能
    - 程序的大部分时间都花在小部分代码上 --要找准优化的点
- 重构起源何处
    - Ward Cunningham 和 Kent Back
- 自动化重构
    - IDE重构工具

## 代码的坏味道
- 神秘命名
- 重复代码
- 过长函数
- 过长参数列表
- 全局数据
- 可变数据
- 发散式变化 