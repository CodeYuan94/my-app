## 接口幂等性的使用场景

- 在一段时间内多次提交表单，比如5秒内，只有第一个提交能生效，其余的都是重复提交

- 比如提交订单的场景，提交前获取一个token，提交时后台进行验证，并清除掉，保证一个token只能提交一次，后面的提交都无效

## 解决方案思考

- 针对某些接口做限制，可以使用`AOP`，减少代码的耦合性
- token的检验可以使用`redis`，操作可以用`lua`脚本，保证原子性
- 可以考虑使用`redisson`分布式锁

## 具体代码

`pom`依赖：

```java
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.10.1</version>
        </dependency>
```

application.properties：

```java
#-------redis连接配置-------
spring.redis.client-type=jedis
spring.redis.host=127.0.0.1
spring.redis.password=123456
spring.redis.port=6379
spring.redis.jedis.pool.max-active=100
spring.redis.jedis.pool.max-idle=100
spring.redis.jedis.pool.min-idle=100
spring.redis.jedis.pool.max-wait=60000
```

一些配置和工具类：

```java
@Component
public class RedisUtils {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 读取缓存
     *
     * @param key
     * @return
     */
    public Object get(final String key) {
        return redisTemplate.opsForValue().get(key);
    }

    /**
     * 写入缓存
     */
    public boolean set( String key, String value) {
        boolean result = false;
        try {
            redisTemplate.opsForValue().set(key, value,1, TimeUnit.DAYS);
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    public boolean set( String key, String value,long time,TimeUnit timeUnit) {
        boolean result = false;
        try {
            redisTemplate.opsForValue().set(key, value,time, timeUnit);
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * 更新缓存
     */
    public boolean getAndSet(final String key, String value) {
        boolean result = false;
        try {
            redisTemplate.opsForValue().getAndSet(key, value);
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * 删除缓存
     */
    public boolean delete(final String key) {
        boolean result = false;
        try {
            result = redisTemplate.delete(key);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * 执行脚本
     * @param script
     * @param list
     * @return
     */
    public Long execute(String script, List list) {
        RedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        return redisTemplate.execute(redisScript,list);
    }

}
```

```java
public class CommonUtils {

    /**
     * 盐
     */
    private static final String slat = "this is my salt";

    /**
     * 1.java原生用法
     *
     * @param dataStr
     * @return
     */
    public static String encrypt(String dataStr) {
        try {
            dataStr = dataStr + slat;
            MessageDigest m = MessageDigest.getInstance("MD5");
            m.update(dataStr.getBytes(StandardCharsets.UTF_8));
            byte[] s = m.digest();
            StringBuilder result = new StringBuilder();
            for (byte b : s) {
                result.append(Integer.toHexString((0x000000FF & b) | 0xFFFFFF00).substring(6));
            }
            return result.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }

    /**
     * 2.spring提供的工具类用法
     * 生成md5
     *
     * @return
     */
    public static String getMD5(String str) {
        String base = str + slat;
        return DigestUtils.md5DigestAsHex(base.getBytes());
    }

    public static String getIpAddress(HttpServletRequest request) {
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}
```

```java
@Configuration
public class RedissonConfiguration {

    @Value("${spring.redis.host}")
    private String redisHost;
    @Value("${spring.redis.port}")
    private String redisPort;
    @Value("${spring.redis.password}")
    private String redisPwd;

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        //单机方式
        config.useSingleServer().setPassword(redisPwd).setAddress("redis://"+redisHost+":"+redisPort);
        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }
}
```



自定义注解，作为切点的位置：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RepeatSubmit {

    /**
     * 防止重复提交，支持两种：参数和令牌
     * 参数是场景一案例,令牌是场景二案例
     */
    enum Type {PARAM,TOKEN}

    Type limitType() default Type.TOKEN;

    long lockTime() default 5;
}
```

定义一个切面，实现切点前后的通知：

```java
@Component
@Aspect
@Slf4j
public class RepeatSubmitAspect {

    @Autowired
    private RedisUtils redisUtils;

    @Autowired
    private RedissonClient redissonClient;

    /**
     * 切点 切在有自定义注解的方法上
     */
    @Pointcut("@annotation(repeatSubmit)")
    public void repeatSubmitPointCut(RepeatSubmit repeatSubmit) {}

    /**
     * 环绕通知
     * @return
     */
    @Around("repeatSubmitPointCut(repeatSubmit)")
    public Object around(ProceedingJoinPoint joinPoint,RepeatSubmit repeatSubmit) throws Throwable{
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        // 执行前操作
        log.info("环绕通知执行前");
        // 是否成功
        boolean flag;
        RepeatSubmit.Type type = repeatSubmit.limitType();
        if (type == (RepeatSubmit.Type.PARAM)) {
            // 参数形式 场景：在一段时间内不能重复提交，只有第一次生效，如频繁多次提交表单
            // key:ip+类名+方法名+账号
            String ip =  CommonUtils.getIpAddress(request);
            Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
            String className = method.getDeclaringClass().getName();
            String key = "repeat-submit:"+CommonUtils.encrypt(String.format("%s-%s-%s-%s",ip,className,method,1L));
            long lockTime = repeatSubmit.lockTime();
            // 获取锁
            RLock lock = redissonClient.getLock(key);
            // tryLock 加锁成功返回true
            flag = lock.tryLock(0,lockTime, TimeUnit.SECONDS);
        } else {
            // 令牌形式 场景：提交前必须拿一次token，只生效一次，如提交订单
            String token = request.getHeader("submit-token");
            if (StringUtils.isEmpty(token)) {
                throw new BusinessException("缺少submit-token");
            }
            // String key = String.format(TestController.ORDER_SUBMIT_TOKEN_KEY,1,token);
            // flag = redisUtils.delete(key);
            // 设置 Lua 脚本，其中 KEYS[1] 是 key
            String script = "if redis.call('get', KEYS[1]) then return redis.call('del', KEYS[1]) else return 0 end";
            // 根据 Key 前缀拼接 Key
            String key = String.format(TestController.ORDER_SUBMIT_TOKEN_KEY,1,token);
            // 执行 Lua 脚本
            Long result = redisUtils.execute(script, Collections.singletonList(key));
            // 根据返回结果判断是否成功成功匹配并删除 Redis 键值对，若果结果不为空和0，则验证通过
            flag = result != null && result > 0;
        }
        if (!flag) {
            log.info("环绕通知执行中");
            log.error("请求重复提交");
            throw new BusinessException("请勿重复提交");
            // 返回null 切点的方法就不会执行
            // return null;
        }
        // 执行该方法
        Object proceed = joinPoint.proceed();
        // 执行后操作
        log.info("环绕通知执行后");
        return proceed;
    }
}
```

controller测试：

```java
@RestController
public class TestController {

    @Autowired
    private RedisUtils redisUtils;

    /**
     * 两个参数 用户账号+token
     */
    public static final String ORDER_SUBMIT_TOKEN_KEY = "order:submit:%s:%s";

    /**
     * limitType = RepeatSubmit.Type.PARAM 就是场景一
     */
    @RepeatSubmit(limitType = RepeatSubmit.Type.TOKEN)
    @GetMapping("/hello")
    public Result test() {
        return Result.success("Hello World！");
    }

    @GetMapping("/token")
    public Result getToken() {
        long account = 1L;
        String token = UUID.randomUUID().toString().replace("-","");
        // key 账号+随机UUID
        String key = String.format(ORDER_SUBMIT_TOKEN_KEY,account,token);
        redisUtils.set(key,String.valueOf(Thread.currentThread().getId()),30, TimeUnit.MINUTES);
        return Result.success(token);
    }
}
```





