# 策略+工厂模式的案例

## 使用前提
代码中出现大量的`if else`或`switch case`,而且多一个条件就需要增加一个条件判断，导致代码越来越臃肿
```java
if(a){
    // do something
}else if(b){
    // do something
}else if(c){
    // do something
}...
```

## 实际场景
后台有个功能，需要根据不同的模板导出不同的excel，不同的厂商有不同的excel格式需求，对应有多种模板
这里的模板有些可以通用，有些单独一个模板，使用枚举列出来
```java
@Getter
public enum CarveTypeEnum {

    /**
     * 通用模板一
     */
    COMMON_ONE("common_one"),

    /**
     * 通用模板二
     */
    COMMON_TWO("common_two"),

    /**
     * 通用模板三
     */
    COMMON_THREE("common_three"),

    /**
     * 拉斐模板
     */
    LAFFEY("laffey"),

    /**
     * 天朗模板
     */
    TNC("tnc");

    /**
     * 模板类型字符串
     * 该字段每个厂商数据库都存储一个
     */
    private final String carveType;

    CarveTypeEnum(String carveType){
        this.carveType = carveType;
    }

    public static CarveTypeEnum getEnumByType(String carveType) {
        for (CarveTypeEnum carveTypeEnum : CarveTypeEnum.values()) {
            if (carveTypeEnum.getCarveType().equals(carveType)) {
                return carveTypeEnum;
            }
        }
        return null;
    }
}
```

每个模板都对应一个excel实体类,这里列举一个
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@ContentRowHeight(25)
@HeadRowHeight(20)
@ColumnWidth(16)
public class CarveExcelFormatOne {

    @ExcelProperty("颜色")
    private String color;
    @ExcelProperty("刻字键位")
    private String carveLeft;
    @ExcelProperty("刻字键位")
    private String carveRight;
    /**
     * 忽略这个字段
     */
    @ExcelIgnore
    private String ignore;

}
```

提供一个策略的抽象，可以用策略接口
```java
public interface CarveExportHandler {

    /**
     * 对应枚举
     * 实现该方法可以匹配枚举和对应的实现策略
     * @return
     */
    CarveTypeEnum getCarveType();

    /**
     * 导出excel 
     * 具体的策略方法
     * @param exportList
     * @param brandName
     * @param export
     * @return 文件地址
     */
    String exportExcel(List<AgentCarveOrder4Export> exportList, String brandName, AgentCarveOrderList4Export export);

}
```

每个模板都实现策略接口，这里列举一个
```java
@Component
public class CommonOneExportHandler implements CarveExportHandler {

    @Override
    public CarveTypeEnum getCarveType() {
        // 一个模板对应一个策略
        return CarveTypeEnum.COMMON_ONE;
    }

    @Override
    public String exportExcel(List<AgentCarveOrder4Export> exportList, String brandName, AgentCarveOrderList4Export export) {
        // 具体实现方法...
    }
}
```

准备一个工厂类，提前加载策略，并提供获取策略的方法
```java
@Component
public class CarveExportHandlerFactory implements InitializingBean, ApplicationContextAware {

    // Map存储 k模板 v策略
    private static final Map<CarveTypeEnum,CarveExportHandler> CARVE_EXPORT_HANDLER_MAP = new HashMap<>();

    private ApplicationContext appContext;

    // 获取策略的方法，通过字符串获取
    public CarveExportHandler getHandler(String carveType) {
        CarveTypeEnum enumByType = CarveTypeEnum.getEnumByType(carveType);
        return CARVE_EXPORT_HANDLER_MAP.get(enumByType);
    }

    // 该方法在bean初始化时调用
    @Override
    public void afterPropertiesSet() throws Exception {
        // 将所有实现的模板放入map
        appContext.getBeansOfType(CarveExportHandler.class)
                .values()
                .forEach(handler -> CARVE_EXPORT_HANDLER_MAP.put(handler.getCarveType(),handler));
    }

    // 该方法在bean实例化后，属性赋值时调用，可拿到容器上下文（在初始化前）
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        appContext = applicationContext;
    }

}
```

调用工厂方法获取策略的实现类,利用多态性调用对应实现类的方法
这样此处代码就不用动了，以后有新的模板，增加枚举和对应的策略实现即可。
```java
public class Test() {

@Autowird
private CarveExportHandlerFactory carveExportHandlerFactory;

public void testExportExcel() {
    String type = "common_one";
    CarveExportHandler handler = carveExportHandlerFactory.getHandler(type);
    handler.exportExcel();
    ...
}

}
```

